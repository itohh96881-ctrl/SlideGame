<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Crowd Runner 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: sans-serif;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 10;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            display: none;
            z-index: 20;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 4px solid #fff;
        }

        button {
            padding: 10px 30px;
            font-size: 20px;
            cursor: pointer;
            background: #FF4500;
            color: white;
            border: none;
            border-radius: 50px;
            margin-top: 20px;
            font-weight: bold;
            box-shadow: 0 4px 0 #b33100;
        }

        button:active {
            box-shadow: 0 2px 0 #b33100;
            transform: translateY(2px);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

    <div id="ui">
        SOLDIERS: <span id="count">1</span><br>
        SCORE: <span id="score">0</span>
    </div>

    <div id="game-over">
        <h1>GAME OVER</h1>
        <p>Score: <span id="final-score">0</span></p>
        <button onclick="resetGame()">RETRY</button>
    </div>

    <script>
        // --- ゲーム設定 ---
        const RUN_SPEED = 0.2;
        const SWAY_SPEED = 0.15;
        const LIMIT_X = 6;
        const GOAL_Z = 350; // ゴール地点

        let scene, camera, renderer;
        let soldiers = []; // 兵士オブジェクトの配列
        let crowdGroup;    // 兵士全体をまとめるグループ
        let score = 0;
        let gameActive = true;
        let frame = 0;

        // マウス位置管理
        let targetX = 0;

        function init() {
            // シーン作成
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // 空色
            scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

            // カメラ
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 8, -12);
            camera.lookAt(0, 0, 5);

            // レンダラー
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // ライト
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(-5, 10, -5);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // 地面
            const groundGeo = new THREE.PlaneGeometry(20, 1000);
            const groundMat = new THREE.MeshLambertMaterial({ color: 0x3cb371 }); // 緑
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.z = 400; // 長い道
            ground.receiveShadow = true;
            scene.add(ground);

            // クラウドグループ（プレイヤー全体）
            crowdGroup = new THREE.Group();
            scene.add(crowdGroup);

            // ゴール・城の作成
            createGoal();

            // 初期兵士追加
            addSoldier();

            // イベントリスナー
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('touchmove', onTouchMove, { passive: false });

            animate();
        }

        // --- 兵士関連 ---
        function addSoldier() {
            const color = 0x1E90FF; // Dodson Blue
            const soldier = createSoldierMesh(color);
            soldiers.push(soldier);
            crowdGroup.add(soldier);
            updateFormation();
            updateUI();
        }

        function createSoldierMesh(color) {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: color });
            const headMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });

            // 体
            const bodyGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.6, 8);
            const body = new THREE.Mesh(bodyGeo, mat);
            body.position.y = 0.5;
            body.castShadow = true;
            group.add(body);

            // 頭
            const headGeo = new THREE.SphereGeometry(0.25, 8, 8);
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.0;
            head.castShadow = true;
            group.add(head);

            return group;
        }

        function updateFormation() {
            const count = soldiers.length;
            if (count === 0) return;

            soldiers[0].position.set(0, 0, 0);

            let radius = 0.5;
            let angle = 0;
            for (let i = 1; i < count; i++) {
                angle += 1;
                radius = 0.4 * Math.sqrt(i);
                const x = Math.cos(angle * 2.4) * radius;
                const z = Math.sin(angle * 2.4) * radius;
                soldiers[i].position.set(x, 0, z);
            }
        }

        // --- 入力処理 ---
        function onMouseMove(event) {
            const x = (event.clientX / window.innerWidth) * 2 - 1;
            targetX = -x * LIMIT_X;
        }

        function onTouchMove(event) {
            event.preventDefault();
            const x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
            targetX = -x * LIMIT_X;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- ゲームループ ---
        function animate() {
            requestAnimationFrame(animate);

            if (!gameActive) return;

            frame++;

            // 前進
            crowdGroup.position.z += RUN_SPEED;
            camera.position.z += RUN_SPEED;

            // 左右移動
            crowdGroup.position.x += (targetX - crowdGroup.position.x) * 0.1;

            // 範囲制限
            if (crowdGroup.position.x > LIMIT_X) crowdGroup.position.x = LIMIT_X;
            if (crowdGroup.position.x < -LIMIT_X) crowdGroup.position.x = -LIMIT_X;

            // 兵士のアニメーション
            soldiers.forEach((s, i) => {
                s.position.y = Math.abs(Math.sin(frame * 0.2 + i)) * 0.2;
                s.rotation.y = Math.sin(frame * 0.1) * 0.2;
            });

            // レベル更新
            updateLevel();

            // ゴール判定
            if (crowdGroup.position.z >= GOAL_Z) {
                gameClear();
            }

            renderer.render(scene, camera);
            updateUI();
        }

        // --- ゴール作成 ---
        function createGoal() {
            // ゴールライン
            const lineGeo = new THREE.PlaneGeometry(15, 2);
            const texLoader = new THREE.TextureLoader();
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white'; ctx.fillRect(0, 0, 64, 64);
            ctx.fillStyle = 'black'; ctx.fillRect(0, 0, 32, 32); ctx.fillRect(32, 32, 32, 32);
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(10, 1);

            const lineMat = new THREE.MeshBasicMaterial({ map: tex });
            const goalLine = new THREE.Mesh(lineGeo, lineMat);
            goalLine.rotation.x = -Math.PI / 2;
            goalLine.position.set(0, 0.05, GOAL_Z);
            scene.add(goalLine);

            // お城（簡易版）
            const castleGroup = new THREE.Group();
            castleGroup.position.set(0, 0, GOAL_Z + 10);

            const mainMat = new THREE.MeshLambertMaterial({ color: 0xFFA500 });
            const roofMat = new THREE.MeshLambertMaterial({ color: 0xFF4500 });

            const base = new THREE.Mesh(new THREE.BoxGeometry(8, 6, 6), mainMat);
            base.position.y = 3;
            castleGroup.add(base);

            const towerGeo = new THREE.CylinderGeometry(1, 1, 8);
            const roofGeo = new THREE.ConeGeometry(1.5, 2, 4);

            [-3, 3].forEach(x => {
                const tower = new THREE.Mesh(towerGeo, mainMat);
                tower.position.set(x, 4, 3);
                castleGroup.add(tower);
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.set(x, 9, 3);
                roof.rotation.y = Math.PI / 4;
                castleGroup.add(roof);
            });
            scene.add(castleGroup);
        }

        function gameClear() {
            gameActive = false;
            const gameOver = document.getElementById('game-over');
            gameOver.style.display = 'block';
            gameOver.querySelector('h1').innerText = "LEVEL CLEARED!";
            gameOver.querySelector('h1').style.color = "#FFD700";
            gameOver.querySelector('#final-score').innerHTML =
                `${Math.floor(score * soldiers.length)}<br>(Soldiers: ${soldiers.length})`;
            gameOver.querySelector('button').innerText = "RETRY";

            // 花火エフェクト
            for (let i = 0; i < 30; i++) {
                const mat = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), mat);
                mesh.position.set(
                    (Math.random() - 0.5) * 15,
                    Math.random() * 10 + 5,
                    GOAL_Z + Math.random() * 10
                );
                scene.add(mesh);
            }
        }

        // --- ゲート・レベル管理 ---
        let gates = [];
        const GATE_INTERVAL = 40;

        function createGate(zPos) {
            const val1 = getRandomGateValue();
            const gate1 = createGateMesh(val1, -2.5, zPos);
            const val2 = getRandomGateValue();
            const gate2 = createGateMesh(val2, 2.5, zPos);
            gates.push(gate1, gate2);
            scene.add(gate1, gate2);
        }

        function getRandomGateValue() {
            const type = Math.random();
            if (type < 0.4) {
                return { op: '+', val: Math.floor(Math.random() * 15) + 5 };
            } else if (type < 0.7) {
                return { op: 'x', val: Math.floor(Math.random() * 3) + 2 };
            } else {
                return { op: '-', val: Math.floor(Math.random() * 10) + 5 };
            }
        }

        function createGateMesh(gateData, x, z) {
            const group = new THREE.Group();
            group.position.set(x, 1.5, z);

            const isGood = (gateData.op === '+' || gateData.op === 'x');
            const color = isGood ? 0x00BFFF : 0xFF4444;

            const geo = new THREE.BoxGeometry(4.5, 3, 0.2);
            const mat = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.3 });
            const mesh = new THREE.Mesh(geo, mat);
            group.add(mesh);

            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: color }));
            group.add(line);

            const text = `${gateData.op}${gateData.val}`;
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = isGood ? 'rgba(0,191,255,0.8)' : 'rgba(255,68,68,0.8)';
            ctx.fillRect(0, 0, 256, 128);
            ctx.font = 'bold 80px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 128, 64);

            const tex = new THREE.CanvasTexture(canvas);
            const textMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
            const textMesh = new THREE.Mesh(new THREE.PlaneGeometry(4, 2), textMat);
            textMesh.position.z = 0.11;
            group.add(textMesh);

            group.userData = { gateData: gateData, active: true };
            return group;
        }

        function updateLevel() {
            const nextGateZ = (Math.floor(crowdGroup.position.z / GATE_INTERVAL) + 1) * GATE_INTERVAL;

            // ゴール手前までしか生成しない
            if (nextGateZ > GOAL_Z - 30) return;

            const lastGate = gates[gates.length - 1];
            if (!lastGate || lastGate.position.z < nextGateZ) {
                createGate(nextGateZ + 20);
            }

            for (let i = gates.length - 1; i >= 0; i--) {
                const gate = gates[i];

                if (gate.userData.active && gate.position.z < crowdGroup.position.z) {
                    const distX = Math.abs(gate.position.x - crowdGroup.position.x);
                    if (distX < 2.5) {
                        applyGateEffect(gate.userData.gateData);
                        gate.userData.active = false;
                        gate.visible = false;
                    }
                }

                if (gate.position.z < crowdGroup.position.z - 20) {
                    scene.remove(gate);
                    gates.splice(i, 1);
                }
            }
        }

        function applyGateEffect(data) {
            let currentCount = soldiers.length;
            let newCount = currentCount;

            if (data.op === '+') {
                newCount += data.val;
            } else if (data.op === 'x') {
                newCount *= data.val;
            } else if (data.op === '-') {
                newCount -= data.val;
            }

            newCount = Math.floor(newCount);
            if (newCount < 1) newCount = 0;

            const diff = newCount - currentCount;

            if (diff > 0) {
                for (let i = 0; i < diff; i++) addSoldier();
            } else if (diff < 0) {
                removeSoldier(Math.abs(diff));
            }
        }

        function removeSoldier(count) {
            for (let i = 0; i < count; i++) {
                if (soldiers.length === 0) break;
                const s = soldiers.pop();
                crowdGroup.remove(s);
            }
            updateFormation();
            updateUI();

            if (soldiers.length === 0) {
                gameOver();
            }
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').innerText = score;
        }

        function updateUI() {
            document.getElementById('count').innerText = soldiers.length;
            score = Math.floor(crowdGroup.position.z);
            document.getElementById('score').innerText = score;
        }

        function resetGame() {
            location.reload();
        }

        init();

    </script>
</body>

</html>