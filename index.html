<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Crowd Runner 3D - Ultimate RPG</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: sans-serif;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 10;
        }

        #coin-ui {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
        }

        #fever-bar-container {
            position: absolute;
            top: 90px;
            left: 10px;
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
        }

        #fever-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FF4500);
            transition: width 0.2s;
        }

        #fever-text {
            position: absolute;
            top: 60px;
            left: 10px;
            font-size: 24px;
            color: #FFD700;
            font-weight: bold;
            display: none;
            text-shadow: 0 0 10px red;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
            }
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            display: none;
            z-index: 20;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 4px solid #fff;
            min-width: 300px;
        }

        .btn {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            background: #FF4500;
            color: white;
            border: none;
            border-radius: 50px;
            margin: 10px;
            font-weight: bold;
            box-shadow: 0 4px 0 #b33100;
        }

        .btn:active {
            box-shadow: 0 2px 0 #b33100;
            transform: translateY(2px);
        }

        .shop-btn {
            background: #4CAF50;
            box-shadow: 0 4px 0 #2E7D32;
        }

        #shop-menu {
            margin-top: 20px;
            text-align: left;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
        }

        .upgrade-item {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .buy-btn {
            font-size: 14px;
            padding: 5px 10px;
            background: #FFD700;
            color: #000;
            box-shadow: 0 2px 0 #B8860B;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

    <div id="ui">
        LEVEL: <span id="level">1</span><br>
        SOLDIERS: <span id="count">1</span><br>
        SCORE: <span id="score">0</span>
    </div>
    <div id="coin-ui">üí∞ <span id="coins">0</span></div>
    <div id="fever-text">FEVER MODE!!</div>
    <div id="fever-bar-container">
        <div id="fever-bar"></div>
    </div>

    <div id="game-over">
        <h1 id="result-title">GAME OVER</h1>
        <p>Score: <span id="final-score">0</span></p>
        <div id="shop-menu">
            <h3>Power Up Shop</h3>
            <div class="upgrade-item">
                <span>Start Soldiers (Lv.<span id="lvl-start">1</span>)</span>
                <button class="btn buy-btn" onclick="buyUpgrade('start')">50G</button>
            </div>
            <div class="upgrade-item">
                <span>Fever Time (Lv.<span id="lvl-fever">1</span>)</span>
                <button class="btn buy-btn" onclick="buyUpgrade('fever')">100G</button>
            </div>
        </div>
        <button id="retry-btn" class="btn" onclick="nextAction()">RETRY</button>
    </div>

    <script>
        // --- „Ç≤„Éº„É†ÂÆöÊï∞ ---
        let RUN_SPEED = 0.3;
        const LIMIT_X = 6;
        let GOAL_Z = 400;

        // Ê∞∏Á∂ö„Éá„Éº„Çø (localStorage)
        let savedData = {
            coins: 0,
            lvlStart: 1, // ÂàùÊúüÂÖµÂ£´Êï∞: 1 + lvl
            lvlFever: 1, // „Éï„Ç£„Éº„Éê„ÉºÊôÇÈñì: 300 + lvl*50 frame
        };

        // „É¨„Éô„É´ÁÆ°ÁêÜ
        let currentLevel = 1;
        let scene, camera, renderer;
        let soldiers = [];
        let crowdGroup;
        let score = 0;
        let gameActive = true;
        let frame = 0;
        let particles = [];
        let obstacles = [];
        let coinObjects = [];
        let projectiles = []; // „Éú„Çπ„ÅÆÊîªÊíÉ

        // „Éï„Ç£„Éº„Éê„Éº
        let feverValue = 0;
        const FEVER_MAX = 100;
        let isFever = false;
        let feverTimer = 0;

        // „Éú„Çπ
        let bossMesh = null;
        let bossHP;
        let bossState = 'waiting';
        let bossAttackTimer = 0;

        let targetX = 0;

        // „Éê„Ç§„Ç™„Éº„É†
        const BIOMES = [
            { name: "GRASS", color: 0x3cb371, sky: 0x87CEEB, deco: 0x228B22 },
            { name: "DESERT", color: 0xE6C229, sky: 0xFFD700, deco: 0x8B4513 },
            { name: "SNOW", color: 0xE0FFFF, sky: 0xF0F8FF, deco: 0xA9A9A9 },
            { name: "LAVA", color: 0x8B0000, sky: 0x330000, deco: 0x000000 }
        ];
        let currentBiome = BIOMES[0];

        function loadData() {
            const d = localStorage.getItem('crowd_runner_save');
            if (d) savedData = JSON.parse(d);
            updateShopUI();
        }

        function saveData() {
            localStorage.setItem('crowd_runner_save', JSON.stringify(savedData));
            updateShopUI();
        }

        function init() {
            loadData();
            setupScene();
            setupGame();

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('touchmove', onTouchMove, { passive: false });

            animate();
        }

        function setupScene() {
            scene = new THREE.Scene();
            updateBiomeColors();

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 8, -12);
            camera.lookAt(0, 0, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            const oldCanvas = document.querySelector('canvas');
            if (oldCanvas) oldCanvas.remove();
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(-5, 10, -5);
            dirLight.castShadow = true;
            scene.add(dirLight);

            const groundGeo = new THREE.PlaneGeometry(30, 2000);
            const groundMat = new THREE.MeshLambertMaterial({ color: currentBiome.color });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.z = 500;
            ground.receiveShadow = true;
            ground.name = "ground";
            scene.add(ground);

            createDecorations();
        }

        function setupGame() {
            soldiers = [];
            particles = [];
            obstacles = [];
            coinObjects = [];
            projectiles = [];
            gates = [];
            bossMesh = null;
            bossState = 'waiting';
            gameActive = true;
            frame = 0;
            crowdGroup = new THREE.Group();
            crowdGroup.position.set(0, 0, 0);
            scene.add(crowdGroup);

            feverValue = 0;
            isFever = false;

            RUN_SPEED = 0.3 + (currentLevel * 0.05);
            GOAL_Z = 350 + (currentLevel * 50);
            bossHP = 50 + (currentLevel * 20);

            createGoal();

            // ÂàùÊúüÂÖµÂ£´Êï∞UP (Shop)
            for (let i = 0; i < savedData.lvlStart; i++) {
                addSoldier();
            }
        }

        function updateBiomeColors() {
            const idx = (currentLevel - 1) % BIOMES.length;
            currentBiome = BIOMES[idx];
            scene.background = new THREE.Color(currentBiome.sky);
            scene.fog = new THREE.Fog(currentBiome.sky, 10, 60);
            const ground = scene.getObjectByName("ground");
            if (ground) ground.material.color.setHex(currentBiome.color);
        }

        function createDecorations() {
            for (let z = 20; z < GOAL_Z; z += 30) {
                [-10, 10].forEach(x => {
                    if (Math.random() > 0.3) {
                        const size = Math.random() * 2 + 1;
                        const geo = new THREE.ConeGeometry(size, size * 2, 4);
                        const mat = new THREE.MeshLambertMaterial({ color: currentBiome.deco });
                        const mesh = new THREE.Mesh(geo, mat);
                        mesh.position.set(x + (Math.random() - 0.5) * 5, size, z + (Math.random() - 0.5) * 10);
                        scene.add(mesh);
                    }
                });
            }
        }

        function createCoin(x, z) {
            const geo = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.z = Math.PI / 2;
            mesh.position.set(x, 1, z);
            scene.add(mesh);
            coinObjects.push(mesh);
        }

        // --- ÂÖµÂ£´ ---
        function addSoldier() {
            const color = isFever ? 0xFFD700 : 0x1E90FF;
            const soldier = createSoldierMesh(color);
            soldiers.push(soldier);
            crowdGroup.add(soldier);
            createParticles(soldier.position.x, soldier.position.y, soldier.position.z + crowdGroup.position.z, 0x00FFFF, 5);
            updateFormation();
            updateUI();
            addFever(2);
        }

        function createSoldierMesh(color) {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: color });
            const headMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const bodyGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.6, 8);
            const body = new THREE.Mesh(bodyGeo, mat);
            body.position.y = 0.5; group.add(body);
            const headGeo = new THREE.SphereGeometry(0.25, 8, 8);
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.0; group.add(head);
            return group;
        }

        function updateFormation() {
            if (soldiers.length === 0) return;
            soldiers[0].position.set(0, 0, 0);
            let angle = 0;
            for (let i = 1; i < soldiers.length; i++) {
                angle += 1;
                const radius = 0.4 * Math.sqrt(i);
                const x = Math.cos(angle * 2.4) * radius;
                const z = Math.sin(angle * 2.4) * radius;
                soldiers[i].position.set(x, 0, z);
            }
        }

        // --- „Éï„Ç£„Éº„Éê„Éº ---
        function addFever(amount) {
            if (isFever) return;
            feverValue += amount;
            if (feverValue >= FEVER_MAX) activateFever();
            updateUI();
        }

        function activateFever() {
            isFever = true;
            feverValue = FEVER_MAX;
            feverTimer = 300 + (savedData.lvlFever - 1) * 50; // ShopÂäπÊûú
            document.getElementById('fever-text').style.display = 'block';
            soldiers.forEach(s => { s.children[0].material.color.setHex(0xFFD700); s.scale.setScalar(1.5); });
            RUN_SPEED *= 1.5;
        }

        function updateFever() {
            if (!isFever) return;
            feverTimer--;
            feverValue = (feverTimer / (300 + (savedData.lvlFever - 1) * 50)) * FEVER_MAX;
            if (feverTimer <= 0) {
                isFever = false;
                feverValue = 0;
                document.getElementById('fever-text').style.display = 'none';
                soldiers.forEach(s => { s.children[0].material.color.setHex(0x1E90FF); s.scale.setScalar(1.0); });
                RUN_SPEED /= 1.5;
            }
            updateUI();
        }

        // --- „Ç®„Éï„Çß„ÇØ„Éà ---
        function createParticles(x, y, z, color, count) {
            for (let i = 0; i < count; i++) {
                const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, z);
                mesh.userData = { vel: new THREE.Vector3((Math.random() - 0.5) * 0.5, Math.random() * 0.5, (Math.random() - 0.5) * 0.5), life: 1.0 };
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel);
                p.userData.vel.y -= 0.02; p.rotation.x += 0.1;
                p.userData.life -= 0.02; p.scale.setScalar(p.userData.life);
                if (p.userData.life <= 0) { scene.remove(p); particles.splice(i, 1); }
            }
        }

        // --- ÂÖ•Âäõ ---
        function onMouseMove(e) { targetX = -(e.clientX / window.innerWidth * 2 - 1) * LIMIT_X; }
        function onTouchMove(e) { e.preventDefault(); targetX = -(e.touches[0].clientX / window.innerWidth * 2 - 1) * LIMIT_X; }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- „Ç≤„Éº„É†„É´„Éº„Éó ---
        function animate() {
            requestAnimationFrame(animate);
            if (!gameActive) return;
            frame++;

            if (bossState !== 'battling') {
                crowdGroup.position.z += RUN_SPEED;
                camera.position.z += RUN_SPEED;
            }

            crowdGroup.position.x += (targetX - crowdGroup.position.x) * 0.1;
            if (crowdGroup.position.x > LIMIT_X) crowdGroup.position.x = LIMIT_X;
            if (crowdGroup.position.x < -LIMIT_X) crowdGroup.position.x = -LIMIT_X;

            soldiers.forEach((s, i) => {
                s.position.y = Math.abs(Math.sin(frame * 0.2 + i)) * 0.2;
                s.rotation.y = Math.sin(frame * 0.1) * 0.2;
            });

            updateLevel();
            updateParticles();
            updateObstacles();
            updateBoss();
            updateFever();
            updateCoins();
            updateProjectiles();

            renderer.render(scene, camera);
        }

        // --- „Ç¥„Éº„É´ÔºÜ„Éú„Çπ ---
        function createGoal() {
            const lineGeo = new THREE.PlaneGeometry(30, 2);
            const texLoader = new THREE.TextureLoader();
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white'; ctx.fillRect(0, 0, 64, 64);
            ctx.fillStyle = 'black'; ctx.fillRect(0, 0, 32, 32); ctx.fillRect(32, 32, 32, 32);
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(20, 1);
            const lineMat = new THREE.MeshBasicMaterial({ map: tex });
            const goalLine = new THREE.Mesh(lineGeo, lineMat);
            goalLine.rotation.x = -Math.PI / 2;
            goalLine.position.set(0, 0.05, GOAL_Z);
            scene.add(goalLine);

            createBoss();
        }

        function createBoss() {
            const group = new THREE.Group();
            group.position.set(0, 0, GOAL_Z + 15);
            const mat = new THREE.MeshLambertMaterial({ color: 0x800080 });
            const bossScalar = 1 + (currentLevel * 0.2);
            const bodyGeo = new THREE.BoxGeometry(6, 12, 4);
            const body = new THREE.Mesh(bodyGeo, mat);
            body.position.y = 6; group.add(body);
            const headGeo = new THREE.BoxGeometry(4, 4, 4);
            const head = new THREE.Mesh(headGeo, mat);
            head.position.y = 14; group.add(head);
            const eyeGeo = new THREE.PlaneGeometry(1, 1);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-1, 14, 2.1); group.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(1, 14, 2.1); group.add(rightEye);

            group.scale.setScalar(bossScalar);
            scene.add(group);
            bossMesh = group;
        }

        function updateBoss() {
            if (!bossMesh || bossState === 'dead') return;
            if (bossState === 'waiting') {
                bossMesh.position.y = Math.sin(frame * 0.05) * 1;
            }
            if (gameActive && crowdGroup.position.z > GOAL_Z - 5) {
                bossState = 'battling';

                // „Éú„Çπ„ÅÆÊîªÊíÉ„É≠„Ç∏„ÉÉ„ÇØ
                bossAttackTimer++;
                if (bossAttackTimer > 60) { // 1Áßí„Åî„Å®„Å´ÊîªÊíÉÂà§ÂÆö
                    if (Math.random() < 0.3) {
                        bossAttack();
                    }
                    bossAttackTimer = 0;
                }

                if (frame % 5 === 0 && soldiers.length > 0) {
                    const s = soldiers.pop();
                    crowdGroup.remove(s);
                    updateFormation();
                    updateUI();
                    createParticles(bossMesh.position.x + (Math.random() - 0.5) * 5, bossMesh.position.y + Math.random() * 10, bossMesh.position.z, 0xFFFF00, 10);
                    bossHP -= (isFever ? 10 : 5);
                    bossMesh.scale.multiplyScalar(0.99); bossMesh.position.x = (Math.random() - 0.5) * 1.0;
                    if (bossHP <= 0) bossDefeated();
                } else if (soldiers.length === 0 && bossHP > 0) {
                    gameOver();
                }
            }
        }

        function bossAttack() {
            // Â≤©Êäï„Åí
            const rockGeo = new THREE.SphereGeometry(1, 8, 8);
            const rockMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
            const rock = new THREE.Mesh(rockGeo, rockMat);
            rock.position.copy(bossMesh.position);
            rock.position.y += 10;
            rock.userData = { vel: new THREE.Vector3((Math.random() - 0.5) * 2, 0, -1) }; // ÊâãÂâç„Å´Êäï„Åí„Çã
            scene.add(rock);
            projectiles.push(rock);
        }

        function bossDefeated() {
            bossState = 'dead';
            scene.remove(bossMesh);
            for (let i = 0; i < 100; i++) createParticles(0, 10, GOAL_Z + 15, Math.random() * 0xffffff, 2);
            savedData.coins += 100; // „Éú„ÇπÊíÉÁ†¥„Éú„Éº„Éä„Çπ
            saveData();
            levelClear();
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.position.add(p.userData.vel);
                p.rotation.x += 0.1;

                // Âú∞Èù¢„Å´„Å§„ÅÑ„Åü„ÇâÊ∂à„Åà„Çã
                if (p.position.y < 0) { scene.remove(p); projectiles.splice(i, 1); continue; }

                // Ë°ùÁ™ÅÂà§ÂÆö
                if (p.position.z < crowdGroup.position.z + 2 && p.position.z > crowdGroup.position.z - 2) {
                    // XË∑ùÈõ¢„ÉÅ„Çß„ÉÉ„ÇØ
                    const distX = Math.abs(p.position.x - crowdGroup.position.x);
                    if (distX < 2 && !isFever) {
                        removeSoldier(3); // Â≤©„ÅØ3‰∫∫Ê∂à„Åô
                        createParticles(p.position.x, 0, p.position.z, 0xFF0000, 10);
                        scene.remove(p); projectiles.splice(i, 1);
                    }
                }
            }
        }

        // --- „Åù„ÅÆ‰ªñ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà ---
        function updateCoins() {
            coinObjects.forEach(c => { c.rotation.y += 0.05; });
            for (let i = coinObjects.length - 1; i >= 0; i--) {
                const c = coinObjects[i];
                if (c.position.z < crowdGroup.position.z + 1 && c.position.z > crowdGroup.position.z - 1) {
                    const distX = Math.abs(c.position.x - crowdGroup.position.x);
                    if (distX < 3) { // Á£ÅÁü≥ÂäπÊûúÔºàÂõ∫ÂÆöÔºâ
                        scene.remove(c); coinObjects.splice(i, 1);
                        savedData.coins++;
                        updateUI();
                    }
                }
            }
        }

        function createHammer(z) {
            const group = new THREE.Group();
            group.position.set(0, 1.5, z);
            const poleGeo = new THREE.CylinderGeometry(0.2, 0.2, 4);
            const pole = new THREE.Mesh(poleGeo, new THREE.MeshLambertMaterial({ color: 0x888888 })); group.add(pole);
            const headGeo = new THREE.BoxGeometry(8, 1, 1);
            const head = new THREE.Mesh(headGeo, new THREE.MeshLambertMaterial({ color: 0x333333 })); head.position.y = 1; group.add(head);
            group.userData = { type: 'hammer', speed: (Math.random() > 0.5 ? 0.05 : -0.05) * (1 + currentLevel * 0.1) };
            scene.add(group); obstacles.push(group);
        }

        function updateObstacles() {
            obstacles.forEach(obs => {
                if (obs.userData.type === 'hammer') { obs.rotation.z += obs.userData.speed; }
                if (obs.position.z < crowdGroup.position.z + 2 && obs.position.z > crowdGroup.position.z - 2) {
                    if (isFever) {
                        scene.remove(obs); obs.position.y = -100;
                        createParticles(obs.position.x, 2, obs.position.z, 0xFFA500, 20);
                    } else {
                        const angle = Math.abs(obs.rotation.z % Math.PI);
                        if (angle < 0.5 || angle > 2.6) {
                            if (Math.random() < 0.1) {
                                removeSoldier(1);
                                createParticles(obs.position.x, 1, obs.position.z, 0xFF0000, 5);
                            }
                        }
                    }
                }
            });
        }

        let gates = [];
        const GATE_INTERVAL = 40;

        function createGate(zPos) {
            const val1 = getRandomGateValue();
            const gate1 = createGateMesh(val1, -2.5, zPos);
            const val2 = getRandomGateValue();
            const gate2 = createGateMesh(val2, 2.5, zPos);
            gates.push(gate1, gate2); scene.add(gate1, gate2);

            if (Math.random() < 0.4 + (currentLevel * 0.1)) createHammer(zPos + 20);
            // „Ç≥„Ç§„É≥ÁîüÊàê
            for (let k = 0; k < 5; k++) createCoin((Math.random() - 0.5) * 8, zPos + 10 + k * 2);
        }

        function getRandomGateValue() {
            const type = Math.random();
            if (type < 0.4) return { op: '+', val: Math.floor(Math.random() * 15) + 5 };
            else if (type < 0.7) return { op: 'x', val: Math.floor(Math.random() * 3) + 2 };
            else return { op: '-', val: Math.floor(Math.random() * 10) + 5 };
        }

        function createGateMesh(gateData, x, z) {
            const group = new THREE.Group(); group.position.set(x, 1.5, z);
            const isGood = (gateData.op === '+' || gateData.op === 'x');
            const color = isGood ? 0x00BFFF : 0xFF4444;
            const geo = new THREE.BoxGeometry(4.5, 3, 0.2);
            const mat = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.3 });
            const mesh = new THREE.Mesh(geo, mat); group.add(mesh);
            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: color })); group.add(line);
            const text = `${gateData.op}${gateData.val}`;
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = isGood ? 'rgba(0,191,255,0.8)' : 'rgba(255,68,68,0.8)'; ctx.fillRect(0, 0, 256, 128);
            ctx.font = 'bold 80px Arial'; ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(text, 128, 64);
            const tex = new THREE.CanvasTexture(canvas);
            const textMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
            const textMesh = new THREE.Mesh(new THREE.PlaneGeometry(4, 2), textMat); textMesh.position.z = 0.11; group.add(textMesh);
            group.userData = { gateData: gateData, active: true };
            return group;
        }

        function updateLevel() {
            const nextGateZ = (Math.floor(crowdGroup.position.z / GATE_INTERVAL) + 1) * GATE_INTERVAL;
            if (nextGateZ > GOAL_Z - 30) return;
            const lastGate = gates[gates.length - 1];
            if (!lastGate || lastGate.position.z < nextGateZ) createGate(nextGateZ + 20);
            for (let i = gates.length - 1; i >= 0; i--) {
                const gate = gates[i];
                if (gate.userData.active && gate.position.z < crowdGroup.position.z) {
                    const distX = Math.abs(gate.position.x - crowdGroup.position.x);
                    if (distX < 2.5) {
                        applyGateEffect(gate.userData.gateData);
                        gate.userData.active = false; gate.visible = false;
                        createParticles(gate.position.x, gate.position.y, gate.position.z, 0xFFFFFF, 20);
                    }
                }
                if (gate.position.z < crowdGroup.position.z - 20) { scene.remove(gate); gates.splice(i, 1); }
            }
        }

        function applyGateEffect(data) {
            let currentCount = soldiers.length;
            let newCount = currentCount;
            if (data.op === '+') newCount += data.val;
            else if (data.op === 'x') newCount *= data.val;
            else if (data.op === '-') newCount -= data.val;
            newCount = Math.floor(newCount); if (newCount < 1) newCount = 0;
            const diff = newCount - currentCount;
            if (diff > 0) for (let i = 0; i < diff; i++) addSoldier();
            else if (diff < 0) removeSoldier(Math.abs(diff));
        }

        function removeSoldier(count) {
            if (isFever) return;
            for (let i = 0; i < count; i++) {
                if (soldiers.length === 0) break;
                const s = soldiers.pop();
                createParticles(s.position.x + crowdGroup.position.x, s.position.y, s.position.z + crowdGroup.position.z, 0xFF0000, 5);
                crowdGroup.remove(s);
            }
            updateFormation(); updateUI();
            if (soldiers.length === 0) gameOver();
        }

        function levelClear() {
            gameActive = false;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('result-title').innerText = `LEVEL ${currentLevel} CLEARED!`;
            document.getElementById('result-title').style.color = "#FFD700";
            document.getElementById('final-score').innerHTML = `Bonus +100 Coins<br>Remaining: ${soldiers.length}`;
            const btn = document.getElementById('retry-btn');
            btn.innerText = "NEXT LEVEL";
            btn.onclick = nextLevel;
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('result-title').innerText = "GAME OVER";
            document.getElementById('result-title').style.color = "#FF0000";
            document.getElementById('final-score').innerText = score;
            const btn = document.getElementById('retry-btn');
            btn.innerText = "RETRY";
            btn.onclick = resetGame;
        }

        function nextLevel() {
            currentLevel++;
            document.getElementById('game-over').style.display = 'none';
            while (scene.children.length > 0) scene.remove(scene.children[0]);
            init();
        }

        function resetGame() {
            // ÁèæÂú®„ÅÆ„É¨„Éô„É´„ÅÆ„Åæ„Åæ„É™„Çª„ÉÉ„Éà (Êú¨Êù•„ÅØ1„Å´Êàª„Åô„Å®„ÅãÈÅ∏„Åπ„Çã„Åπ„Åç„Å†„ÅåÁ∞°ÊòìÁöÑ„Å´)
            document.getElementById('game-over').style.display = 'none';
            while (scene.children.length > 0) scene.remove(scene.children[0]);
            init();
        }

        function nextAction() {
            if (soldiers.length > 0) nextLevel();
            else resetGame();
        }

        function updateUI() {
            document.getElementById('level').innerText = currentLevel;
            document.getElementById('count').innerText = soldiers.length;
            score = Math.floor(crowdGroup.position.z) + (currentLevel - 1) * 1000;
            document.getElementById('score').innerText = score;
            document.getElementById('coins').innerText = savedData.coins;
            document.getElementById('fever-bar').style.width = (feverValue / FEVER_MAX * 100) + '%';
        }

        // --- Shop ---
        function updateShopUI() {
            document.getElementById('coins').innerText = savedData.coins;
            document.getElementById('lvl-start').innerText = savedData.lvlStart;
            document.getElementById('lvl-fever').innerText = savedData.lvlFever;
        }

        function buyUpgrade(type) {
            let cost = 0;
            if (type === 'start') {
                cost = 50 * savedData.lvlStart; // „Ç≥„Çπ„Éà‰∏äÊòá
                if (savedData.coins >= cost) {
                    savedData.coins -= cost;
                    savedData.lvlStart++;
                    saveData();
                }
            } else if (type === 'fever') {
                cost = 100 * savedData.lvlFever;
                if (savedData.coins >= cost) {
                    savedData.coins -= cost;
                    savedData.lvlFever++;
                    saveData();
                }
            }
        }

        init();

    </script>
</body>

</html>