<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Crowd Runner 3D - Ultimate</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: sans-serif;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 10;
        }

        #fever-bar-container {
            position: absolute;
            top: 80px;
            left: 10px;
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
        }

        #fever-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FF4500);
            transition: width 0.2s;
        }

        #fever-text {
            position: absolute;
            top: 50px;
            left: 10px;
            font-size: 24px;
            color: #FFD700;
            font-weight: bold;
            display: none;
            text-shadow: 0 0 10px red;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
            }
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            display: none;
            z-index: 20;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 4px solid #fff;
        }

        button {
            padding: 10px 30px;
            font-size: 20px;
            cursor: pointer;
            background: #FF4500;
            color: white;
            border: none;
            border-radius: 50px;
            margin-top: 20px;
            font-weight: bold;
            box-shadow: 0 4px 0 #b33100;
        }

        button:active {
            box-shadow: 0 2px 0 #b33100;
            transform: translateY(2px);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

    <div id="ui">
        LEVEL: <span id="level">1</span><br>
        SOLDIERS: <span id="count">1</span><br>
        SCORE: <span id="score">0</span>
    </div>
    <div id="fever-text">FEVER MODE!!</div>
    <div id="fever-bar-container">
        <div id="fever-bar"></div>
    </div>

    <div id="game-over">
        <h1 id="result-title">GAME OVER</h1>
        <p>Score: <span id="final-score">0</span></p>
        <button id="retry-btn" onclick="resetGame()">RETRY</button>
    </div>

    <script>
        // --- ゲーム設定 ---
        let RUN_SPEED = 0.3;
        const LIMIT_X = 6;
        let GOAL_Z = 400;

        // レベル管理
        let currentLevel = 1;

        let scene, camera, renderer;
        let soldiers = [];
        let crowdGroup;
        let score = 0;
        let gameActive = true;
        let frame = 0;
        let particles = [];
        let obstacles = [];
        let sceneryObjects = []; // デコレーション

        // フィーバー管理
        let feverValue = 0;
        const FEVER_MAX = 100;
        let isFever = false;
        let feverTimer = 0;

        // ボス変数
        let bossMesh = null;
        let bossHP;
        let bossState = 'waiting';

        let targetX = 0;

        // バイオーム設定
        const BIOMES = [
            { name: "GRASS", color: 0x3cb371, sky: 0x87CEEB, deco: 0x228B22 }, // 草原
            { name: "DESERT", color: 0xE6C229, sky: 0xFFD700, deco: 0x8B4513 }, // 砂漠
            { name: "SNOW", color: 0xE0FFFF, sky: 0xF0F8FF, deco: 0xA9A9A9 }, // 雪原
            { name: "LAVA", color: 0x8B0000, sky: 0x330000, deco: 0x000000 }  // 溶岩
        ];
        let currentBiome = BIOMES[0];

        function init() {
            setupScene();
            setupGame();

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('touchmove', onTouchMove, { passive: false });

            animate();
        }

        function setupScene() {
            scene = new THREE.Scene();
            updateBiomeColors();

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 8, -12);
            camera.lookAt(0, 0, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            // 既存のcanvasがあれば削除
            const oldCanvas = document.querySelector('canvas');
            if (oldCanvas) oldCanvas.remove();
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(-5, 10, -5);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // 地面
            const groundGeo = new THREE.PlaneGeometry(30, 2000);
            const groundMat = new THREE.MeshLambertMaterial({ color: currentBiome.color });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.z = 500;
            ground.receiveShadow = true;
            ground.name = "ground";
            scene.add(ground);

            createDecorations();
        }

        function setupGame() {
            soldiers = [];
            particles = [];
            obstacles = [];
            gates = [];
            bossMesh = null;
            bossState = 'waiting';
            gameActive = true;
            frame = 0;
            crowdGroup = new THREE.Group();
            crowdGroup.position.set(0, 0, 0);
            scene.add(crowdGroup);

            feverValue = 0;
            isFever = false;

            // レベルに応じた調整
            RUN_SPEED = 0.3 + (currentLevel * 0.05);
            GOAL_Z = 350 + (currentLevel * 50);
            bossHP = 50 + (currentLevel * 20);

            createGoal();
            addSoldier(); // スタートの1人
        }

        function updateBiomeColors() {
            const idx = (currentLevel - 1) % BIOMES.length;
            currentBiome = BIOMES[idx];
            scene.background = new THREE.Color(currentBiome.sky);
            scene.fog = new THREE.Fog(currentBiome.sky, 10, 60);

            const ground = scene.getObjectByName("ground");
            if (ground) ground.material.color.setHex(currentBiome.color);
        }

        function createDecorations() {
            // 道の両脇にオブジェクトを配置
            for (let z = 20; z < GOAL_Z; z += 30) {
                [-10, 10].forEach(x => {
                    if (Math.random() > 0.3) {
                        const size = Math.random() * 2 + 1;
                        const geo = new THREE.ConeGeometry(size, size * 2, 4);
                        const mat = new THREE.MeshLambertMaterial({ color: currentBiome.deco });
                        const mesh = new THREE.Mesh(geo, mat);
                        mesh.position.set(x + (Math.random() - 0.5) * 5, size, z + (Math.random() - 0.5) * 10);
                        scene.add(mesh);
                    }
                });
            }
        }

        // --- 兵士関連 ---
        function addSoldier() {
            const color = isFever ? 0xFFD700 : 0x1E90FF;
            const soldier = createSoldierMesh(color);
            soldiers.push(soldier);
            crowdGroup.add(soldier);
            createParticles(soldier.position.x, soldier.position.y, soldier.position.z + crowdGroup.position.z, 0x00FFFF, 5);
            updateFormation();
            updateUI();

            // フィーバー加算
            addFever(2);
        }

        function createSoldierMesh(color) {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: color });
            const headMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });

            const bodyGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.6, 8);
            const body = new THREE.Mesh(bodyGeo, mat);
            body.position.y = 0.5;
            body.castShadow = true;
            group.add(body);

            const headGeo = new THREE.SphereGeometry(0.25, 8, 8);
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.0;
            head.castShadow = true;
            group.add(head);

            group.userData = { isSoldier: true };
            return group;
        }

        function updateFormation() {
            const count = soldiers.length;
            if (count === 0) return;
            soldiers[0].position.set(0, 0, 0);
            let radius = 0.5;
            let angle = 0;
            for (let i = 1; i < count; i++) {
                angle += 1;
                radius = 0.4 * Math.sqrt(i);
                const x = Math.cos(angle * 2.4) * radius;
                const z = Math.sin(angle * 2.4) * radius;
                soldiers[i].position.set(x, 0, z);
            }
        }

        // --- フィーバー ---
        function addFever(amount) {
            if (isFever) return;
            feverValue += amount;
            if (feverValue >= FEVER_MAX) {
                activateFever();
            }
            updateUI();
        }

        function activateFever() {
            isFever = true;
            feverValue = FEVER_MAX;
            feverTimer = 300; // 5秒くらい (60fps換算)
            document.getElementById('fever-text').style.display = 'block';

            // 全員金色に
            soldiers.forEach(s => {
                s.children[0].material.color.setHex(0xFFD700);
                s.scale.setScalar(1.5); // 巨大化
            });

            RUN_SPEED *= 1.5; // 加速
        }

        function updateFever() {
            if (!isFever) return;
            feverTimer--;
            feverValue = (feverTimer / 300) * FEVER_MAX;

            if (feverTimer <= 0) {
                isFever = false;
                feverValue = 0;
                document.getElementById('fever-text').style.display = 'none';
                // 元に戻す
                soldiers.forEach(s => {
                    s.children[0].material.color.setHex(0x1E90FF);
                    s.scale.setScalar(1.0);
                });
                RUN_SPEED /= 1.5;
            }
            updateUI();
        }

        // --- エフェクト ---
        function createParticles(x, y, z, color, count) {
            for (let i = 0; i < count; i++) {
                const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, z);
                mesh.userData = {
                    vel: new THREE.Vector3((Math.random() - 0.5) * 0.5, Math.random() * 0.5, (Math.random() - 0.5) * 0.5),
                    life: 1.0
                };
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel);
                p.userData.vel.y -= 0.02;
                p.rotation.x += 0.1;
                p.userData.life -= 0.02;
                p.scale.setScalar(p.userData.life);
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        // --- 入力 ---
        function onMouseMove(event) {
            const x = (event.clientX / window.innerWidth) * 2 - 1;
            targetX = -x * LIMIT_X;
        }
        function onTouchMove(event) {
            event.preventDefault();
            const x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
            targetX = -x * LIMIT_X;
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- ゲームループ ---
        function animate() {
            requestAnimationFrame(animate);
            if (!gameActive) return;
            frame++;

            if (bossState !== 'battling') {
                crowdGroup.position.z += RUN_SPEED;
                camera.position.z += RUN_SPEED;
            }

            // 左右移動
            crowdGroup.position.x += (targetX - crowdGroup.position.x) * 0.1;
            if (crowdGroup.position.x > LIMIT_X) crowdGroup.position.x = LIMIT_X;
            if (crowdGroup.position.x < -LIMIT_X) crowdGroup.position.x = -LIMIT_X;

            soldiers.forEach((s, i) => {
                s.position.y = Math.abs(Math.sin(frame * 0.2 + i)) * 0.2;
                s.rotation.y = Math.sin(frame * 0.1) * 0.2;
            });

            updateLevel();
            updateParticles();
            updateObstacles();
            updateBoss();
            updateFever();

            renderer.render(scene, camera);
        }

        // --- ゴール＆ボス ---
        function createGoal() {
            const lineGeo = new THREE.PlaneGeometry(30, 2);
            const texLoader = new THREE.TextureLoader();
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white'; ctx.fillRect(0, 0, 64, 64);
            ctx.fillStyle = 'black'; ctx.fillRect(0, 0, 32, 32); ctx.fillRect(32, 32, 32, 32);
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(20, 1);
            const lineMat = new THREE.MeshBasicMaterial({ map: tex });
            const goalLine = new THREE.Mesh(lineGeo, lineMat);
            goalLine.rotation.x = -Math.PI / 2;
            goalLine.position.set(0, 0.05, GOAL_Z);
            scene.add(goalLine);

            createBoss();
        }

        function createBoss() {
            const group = new THREE.Group();
            group.position.set(0, 0, GOAL_Z + 15);

            const mat = new THREE.MeshLambertMaterial({ color: 0x800080 }); // 紫
            const bossScalar = 1 + (currentLevel * 0.2); // レベルでボスもでかく

            const bodyGeo = new THREE.BoxGeometry(6, 12, 4);
            const body = new THREE.Mesh(bodyGeo, mat);
            body.position.y = 6;
            group.add(body);

            const headGeo = new THREE.BoxGeometry(4, 4, 4);
            const head = new THREE.Mesh(headGeo, mat);
            head.position.y = 14;
            group.add(head);

            const eyeGeo = new THREE.PlaneGeometry(1, 1);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-1, 14, 2.1);
            group.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(1, 14, 2.1);
            group.add(rightEye);

            group.scale.setScalar(bossScalar);
            scene.add(group);
            bossMesh = group;
        }

        function updateBoss() {
            if (!bossMesh || bossState === 'dead') return;
            if (bossState === 'waiting') {
                bossMesh.position.y = Math.sin(frame * 0.05) * 1;
            }
            if (gameActive && crowdGroup.position.z > GOAL_Z - 5) {
                bossState = 'battling';
                if (frame % 5 === 0 && soldiers.length > 0) {
                    const s = soldiers.pop();
                    crowdGroup.remove(s);
                    updateFormation();
                    updateUI();

                    createParticles(
                        bossMesh.position.x + (Math.random() - 0.5) * 5,
                        bossMesh.position.y + Math.random() * 10,
                        bossMesh.position.z,
                        0xFFFF00, 10
                    );

                    bossHP -= (isFever ? 10 : 5); // フィーバーなら2倍ダメージ
                    bossMesh.scale.multiplyScalar(0.99);
                    bossMesh.position.x = (Math.random() - 0.5) * 1.0;

                    if (bossHP <= 0) {
                        bossDefeated();
                    }
                } else if (soldiers.length === 0 && bossHP > 0) {
                    gameOver();
                }
            }
        }

        function bossDefeated() {
            bossState = 'dead';
            scene.remove(bossMesh);
            for (let i = 0; i < 100; i++) {
                createParticles(0, 10, GOAL_Z + 15, Math.random() * 0xffffff, 2);
            }
            levelClear();
        }

        // --- 障害物 ---
        function createHammer(z) {
            const group = new THREE.Group();
            group.position.set(0, 1.5, z);
            const poleGeo = new THREE.CylinderGeometry(0.2, 0.2, 4);
            const pole = new THREE.Mesh(poleGeo, new THREE.MeshLambertMaterial({ color: 0x888888 }));
            group.add(pole);
            const headGeo = new THREE.BoxGeometry(8, 1, 1);
            const head = new THREE.Mesh(headGeo, new THREE.MeshLambertMaterial({ color: 0x333333 }));
            head.position.y = 1;
            group.add(head);
            group.userData = { type: 'hammer', speed: (Math.random() > 0.5 ? 0.05 : -0.05) * (1 + currentLevel * 0.1) };
            scene.add(group);
            obstacles.push(group);
        }

        function updateObstacles() {
            obstacles.forEach(obs => {
                if (obs.userData.type === 'hammer') {
                    obs.rotation.z += obs.userData.speed;
                }
                if (obs.position.z < crowdGroup.position.z + 2 && obs.position.z > crowdGroup.position.z - 2) {
                    if (isFever) {
                        // フィーバー中は障害物を破壊！
                        scene.remove(obs);
                        obs.position.y = -100; // 画面外へ
                        createParticles(obs.position.x, 2, obs.position.z, 0xFFA500, 20);
                    } else {
                        const angle = Math.abs(obs.rotation.z % Math.PI);
                        if (angle < 0.5 || angle > 2.6) {
                            if (Math.random() < 0.1) {
                                removeSoldier(1);
                                createParticles(obs.position.x, 1, obs.position.z, 0xFF0000, 5);
                            }
                        }
                    }
                }
            });
        }

        // --- レベル管理 ---
        let gates = [];
        const GATE_INTERVAL = 40;

        function createGate(zPos) {
            const val1 = getRandomGateValue();
            const gate1 = createGateMesh(val1, -2.5, zPos);
            const val2 = getRandomGateValue();
            const gate2 = createGateMesh(val2, 2.5, zPos);
            gates.push(gate1, gate2);
            scene.add(gate1, gate2);

            if (Math.random() < 0.4 + (currentLevel * 0.1)) { // レベルが高いと障害物増える
                createHammer(zPos + 20);
            }
        }

        function getRandomGateValue() {
            const type = Math.random();
            if (type < 0.4) {
                return { op: '+', val: Math.floor(Math.random() * 15) + 5 };
            } else if (type < 0.7) {
                return { op: 'x', val: Math.floor(Math.random() * 3) + 2 };
            } else {
                return { op: '-', val: Math.floor(Math.random() * 10) + 5 };
            }
        }

        function createGateMesh(gateData, x, z) {
            const group = new THREE.Group();
            group.position.set(x, 1.5, z);
            const isGood = (gateData.op === '+' || gateData.op === 'x');
            const color = isGood ? 0x00BFFF : 0xFF4444;

            const geo = new THREE.BoxGeometry(4.5, 3, 0.2);
            const mat = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 0.3 });
            const mesh = new THREE.Mesh(geo, mat);
            group.add(mesh);

            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: color }));
            group.add(line);

            const text = `${gateData.op}${gateData.val}`;
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = isGood ? 'rgba(0,191,255,0.8)' : 'rgba(255,68,68,0.8)';
            ctx.fillRect(0, 0, 256, 128);
            ctx.font = 'bold 80px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 128, 64);

            const tex = new THREE.CanvasTexture(canvas);
            const textMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
            const textMesh = new THREE.Mesh(new THREE.PlaneGeometry(4, 2), textMat);
            textMesh.position.z = 0.11;
            group.add(textMesh);

            group.userData = { gateData: gateData, active: true };
            return group;
        }

        function updateLevel() {
            const nextGateZ = (Math.floor(crowdGroup.position.z / GATE_INTERVAL) + 1) * GATE_INTERVAL;
            if (nextGateZ > GOAL_Z - 30) return;
            const lastGate = gates[gates.length - 1];
            if (!lastGate || lastGate.position.z < nextGateZ) {
                createGate(nextGateZ + 20);
            }
            for (let i = gates.length - 1; i >= 0; i--) {
                const gate = gates[i];
                if (gate.userData.active && gate.position.z < crowdGroup.position.z) {
                    const distX = Math.abs(gate.position.x - crowdGroup.position.x);
                    if (distX < 2.5) {
                        applyGateEffect(gate.userData.gateData);
                        gate.userData.active = false;
                        gate.visible = false;
                        createParticles(gate.position.x, gate.position.y, gate.position.z, 0xFFFFFF, 20);
                    }
                }
                if (gate.position.z < crowdGroup.position.z - 20) {
                    scene.remove(gate);
                    gates.splice(i, 1);
                }
            }
        }

        function applyGateEffect(data) {
            let currentCount = soldiers.length;
            let newCount = currentCount;
            if (data.op === '+') { newCount += data.val; }
            else if (data.op === 'x') { newCount *= data.val; }
            else if (data.op === '-') { newCount -= data.val; }
            newCount = Math.floor(newCount);
            if (newCount < 1) newCount = 0;
            const diff = newCount - currentCount;
            if (diff > 0) { for (let i = 0; i < diff; i++) addSoldier(); }
            else if (diff < 0) { removeSoldier(Math.abs(diff)); }
        }

        function removeSoldier(count) {
            if (isFever) return; // フィーバー中は無敵

            for (let i = 0; i < count; i++) {
                if (soldiers.length === 0) break;
                const s = soldiers.pop();
                createParticles(s.position.x + crowdGroup.position.x, s.position.y, s.position.z + crowdGroup.position.z, 0xFF0000, 5);
                crowdGroup.remove(s);
            }
            updateFormation();
            updateUI();
            if (soldiers.length === 0) { gameOver(); }
        }

        function levelClear() {
            gameActive = false;
            const gameOver = document.getElementById('game-over');
            gameOver.style.display = 'block';
            document.getElementById('result-title').innerText = `LEVEL ${currentLevel} CLEARED!`;
            document.getElementById('result-title').style.color = "#FFD700";
            document.getElementById('final-score').innerHTML = `Next Difficulty Up!<br>Remaining: ${soldiers.length}`;
            const btn = document.getElementById('retry-btn');
            btn.innerText = "NEXT LEVEL";
            btn.onclick = nextLevel;
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('result-title').innerText = "GAME OVER";
            document.getElementById('result-title').style.color = "#FF0000";
            document.getElementById('final-score').innerText = score;
            const btn = document.getElementById('retry-btn');
            btn.innerText = "RETRY";
            btn.onclick = resetGame;
        }

        function nextLevel() {
            currentLevel++;
            document.getElementById('game-over').style.display = 'none';

            // シーン再構築
            while (scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }

            // 変数リセット
            init();
        }

        function updateUI() {
            document.getElementById('level').innerText = currentLevel;
            document.getElementById('count').innerText = soldiers.length;
            score = Math.floor(crowdGroup.position.z) + (currentLevel - 1) * 1000;
            document.getElementById('score').innerText = score;

            document.getElementById('fever-bar').style.width = (feverValue / FEVER_MAX * 100) + '%';
        }

        function resetGame() {
            location.reload();
        }

        init();

    </script>
</body>

</html>